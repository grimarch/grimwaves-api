name: CI Pipeline

on:
  push:
    branches: ['**']
    tags: ['v*.*.*'] # Также запускаем по тегам вида v1.2.3
  pull_request:
    branches: ['**']

permissions:
  contents: read
  packages: write # Необходимо для push в GHCR

jobs:
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python and Poetry
        uses: ./.github/actions/setup-python-poetry
        # Опционально, если нужны другие версии Python/Poetry:
        # with:
        #   python-version: '3.x' 
        #   poetry-version: '1.x.x'

      - name: Run Ruff Linter
        run: poetry run ruff check .

      - name: Run MyPy Type Checker
        run: poetry run mypy .

  security:
    name: Security Checks
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python and Poetry
        uses: ./.github/actions/setup-python-poetry

      - name: Check for vulnerabilities (Safety)
        env:
          SAFETY_API_KEY: ${{ secrets.SAFETY_API_KEY }}
        run: make check-vulns

      - name: Check code security (Bandit)
        run: make check-code-security

      - name: Scan configuration files (Trivy)
        run: make scan-config

  unit_test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python and Poetry
        uses: ./.github/actions/setup-python-poetry

      - name: Create reports directory
        run: mkdir -p reports

      - name: Run unit tests with coverage
        run: |
          poetry run pytest \
            --cov=grimwaves_api \
            --cov-report=xml:reports/unit-coverage.xml \
            --cov-report=html:reports/unit-htmlcov \
            --junitxml=reports/unit-junit-tests.xml \
            tests/unit

      - name: Upload unit test results (JUnit XML)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results-junit
          path: reports/unit-junit-tests.xml

      - name: Upload unit coverage report (XML)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-coverage-report-xml
          path: reports/unit-coverage.xml

      - name: Upload unit coverage report (HTML)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-coverage-report-html
          path: reports/unit-htmlcov

  integration_test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: lint # For now, will update to depend on unit_test if needed, or run in parallel
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python and Poetry
        uses: ./.github/actions/setup-python-poetry

      - name: Create reports directory
        run: mkdir -p reports

      - name: Run integration tests with coverage
        run: |
          poetry run pytest \
            --cov=grimwaves_api \
            --cov-append \
            --cov-report=xml:reports/integration-coverage.xml \
            --cov-report=html:reports/integration-htmlcov \
            --junitxml=reports/integration-junit-tests.xml \
            tests/integration --run-integration

      - name: Upload integration test results (JUnit XML)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results-junit
          path: reports/integration-junit-tests.xml

      - name: Upload integration coverage report (XML)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-coverage-report-xml
          path: reports/integration-coverage.xml

      - name: Upload integration coverage report (HTML)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-coverage-report-html
          path: reports/integration-htmlcov

  e2e_test:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: [unit_test, integration_test] # Depends on unit/integration tests passing
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python and Poetry
        uses: ./.github/actions/setup-python-poetry

      - name: Update /etc/hosts for local domain resolution
        run: |
          echo "127.0.0.1 api.grimwaves.local traefik.grimwaves.local grimwaves.local" | sudo tee -a /etc/hosts
          echo "127.0.0.1 health.local" | sudo tee -a /etc/hosts
      
      - name: Ensure Vault Agent all directories exists
        run: mkdir -p vault-agent/{token,rendered,templates,sockets,auth,certs}

      - name: Set up Vault Agent credentials
        run: |
          echo "${{ secrets.VAULT_ROLE_ID }}" > vault-agent/auth/role-id
          echo "${{ secrets.VAULT_SECRET_ID }}" > vault-agent/auth/secret-id
          echo "Vault Agent Role ID and Secret ID files created with correct names."
          # ls -l vault-agent/auth/ # Optional: list files for debugging

      - name: Start services for E2E tests
        env:
          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
          VAULT_SERVER_IP: ${{ secrets.VAULT_SERVER_IP }}
          VAULT_SKIP_VERIFY: "true"
          VAULT_ROLE_ID: ${{ secrets.VAULT_ROLE_ID }}
          VAULT_SECRET_ID: ${{ secrets.VAULT_SECRET_ID }}
          VAULT_PROJECT_NAME: learn-vault-lab
        run: |
          docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d --build
          
      # Логи vault-agent могут быть полезны при сбое, но не при успехе
      - name: Show vault-agent debug info on failure
        if: failure()
        run: |
          echo "---- Debug: Contents of /vault-agent/auth/ inside vault-agent container ----"
          docker compose exec vault-agent ls -la /vault-agent/auth/ || echo "Failed to list /vault-agent/auth/"
          echo "---- Debug: Contents of /vault-agent/config/agent.hcl inside vault-agent container ----"
          docker compose exec vault-agent cat /vault-agent/config/agent.hcl || echo "agent.hcl not found or cat failed"
          echo "---- Debug: Logs from vault-agent ----"
          docker compose logs vault-agent || echo "Failed to get vault-agent logs"

      - name: Wait for API to be ready
        run: |
          echo "Waiting for API at https://api.grimwaves.local/health ..."
          timeout=120 # Total wait time in seconds (e.g., 2 minutes)
          interval=5  # Interval between checks
          elapsed=0
          until curl --output /dev/null --silent --fail --insecure https://api.grimwaves.local/health; do
            if [ $elapsed -ge $timeout ]; then
              echo "Timeout waiting for API!"
              docker compose logs
              exit 1
            fi
            printf '.'
            sleep $interval
            elapsed=$(($elapsed + $interval))
          done
          echo "API is up!"

      - name: Create reports directory for E2E tests
        run: mkdir -p reports && sudo chown -R runner:runner reports

      - name: Install Vault CLI
        run: |
          curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
          sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"
          sudo apt-get update && sudo apt-get install vault

      - name: Setup Vault DNS resolution
        run: |
          # Add Vault domain to /etc/hosts for DNS resolution in CI
          VAULT_IP="${{ secrets.VAULT_SERVER_IP }}"
          echo "$VAULT_IP vault-docker-lab1.vault-docker-lab.lan" | sudo tee -a /etc/hosts
          echo "✅ Added Vault domain ($VAULT_IP) to /etc/hosts"

      - name: Get Vault Token
        id: vault-token
        run: |
          export VAULT_ADDR=${{ secrets.VAULT_ADDR }}
          # Using the files created in the previous step
          export VAULT_TOKEN=$(vault write -tls-skip-verify -field=token auth/approle/login \
                              role_id=@vault-agent/auth/role-id \
                              secret_id=@vault-agent/auth/secret-id)
          echo "VAULT_TOKEN=$VAULT_TOKEN" >> $GITHUB_ENV
          echo "token=$VAULT_TOKEN" >> $GITHUB_OUTPUT

      - name: Prepare logging directory
        run: |
          mkdir -p logs
          sudo chmod 777 logs
          sudo touch logs/app.log
          sudo chmod 666 logs/app.log
          sudo chown -R runner:runner logs

      - name: Run E2E Tests
        env:
          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
          VAULT_TOKEN: ${{ steps.vault-token.outputs.token }}
        run: |
          poetry run pytest \
            --cov=grimwaves_api \
            --cov-report=xml:reports/coverage.xml \
            --cov-report=html:reports/htmlcov \
            --junitxml=reports/junit-e2e.xml \
            tests/e2e 

      - name: Upload E2E test results (JUnit XML)
        if: always() # Run even if tests fail
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results-junit
          path: reports/junit-e2e.xml # Assuming E2E tests output to this file
          retention-days: 7
      
      - name: Docker logs on failure
        if: failure()
        run: docker compose -f docker-compose.yml -f docker-compose.dev.yml logs

      - name: Stop services
        if: always() # Always run to clean up
        run: docker compose -f docker-compose.yml -f docker-compose.dev.yml down

  build_and_push_docker_image:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [unit_test, integration_test, e2e_test] # Now depends on unit/integration and E2E tests
    permissions: # Добавляем/обновляем permissions для загрузки SARIF
      contents: read
      packages: write
      security-events: write # Необходимо для github/codeql-action/upload-sarif
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}
          tags: |
            type=schedule
            type=ref,event=branch
            type=ref,event=tag
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha,prefix=,suffix=,event=branch
            type=raw,value=latest,enable=${{ github.ref == format('refs/heads/{0}', 'master') }}
            
      - name: Build and push Docker image
        id: build_push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Scan image with Trivy
        if: github.event_name != 'pull_request' # Сканируем только если образ был опубликован
        uses: aquasecurity/trivy-action@master 
        with:
          image-ref: 'ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ steps.meta.outputs.version }}' # Используем один из тегов, желательно самый конкретный, например, тег ветки или git-тег
          format: 'template'
          template: '@/contrib/sarif.tpl'
          output: 'trivy-results.sarif'
          severity: 'HIGH,CRITICAL' # Fail on HIGH or CRITICAL vulnerabilities
          exit-code: '1' # Exit with code 1 if vulnerabilities of specified severity are found
          vuln-type: 'os,library'
          ignore-unfixed: true # Игнорировать уязвимости, для которых нет исправления

      - name: Upload Trivy scan results to GitHub Security Tab
        if: github.event_name != 'pull_request' # Только если сканирование было выполнено
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'docker-image' # Категория для группировки в Security Tab

      - name: Upload Trivy scan report as artifact (table format)
        if: github.event_name != 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-report-table
          path: trivy-scan-report-table.txt # Временный файл для отчета в формате table
          retention-days: 7
      
      - name: Run Trivy again for table output (temporary step for artifact)
        if: github.event_name != 'pull_request'
        run: |
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v $PWD:/workdir \
            aquasec/trivy:latest image \
            --format table \
            --output /workdir/trivy-scan-report-table.txt \
            --severity UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL \
            --vuln-type os,library \
            --ignore-unfixed \
            ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ steps.meta.outputs.version }}

  create_release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: build_and_push_docker_image # Запускаем после успешной сборки и пуша образа
    if: startsWith(github.ref, 'refs/tags/v') # Только для тегов вида v*.*.*
    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Нужен для доступа к README, если захотим его прикрепить или использовать в теле

      - name: Get image digest
        # Этот шаг может быть сложнее, если build_push не выводит дайджест напрямую
        # или если нужно получить дайджест конкретного тега из GHCR.
        # Для простоты пока пропустим точное указание дайджеста в релизе.
        # Дайджест образа доступен в outputs шага docker/build-push-action, если он был выполнен:
        # ${{ needs.build_and_push_docker_image.outputs.digest }} - но needs.job_id.outputs не работает так просто
        # Вместо этого можно передавать outputs между jobs через артефакты или использовать API.
        # Пока сделаем релиз без явного дайджеста образа в теле.
        run: echo "Image digest can be found in the build logs or GHCR for tag ${{ github.ref_name }}"

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }} # Используем имя тега, которое вызвало workflow
          release_name: Release ${{ github.ref_name }}
          body: |
            Automated release for tag ${{ github.ref_name }}.
            Docker image published to GHCR with tag: `${{ github.ref_name }}`
            (and other tags like semver, branch, sha if applicable during the build).
            
            To pull the image:
            `docker pull ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ github.ref_name }}`
            
            *The README for this version is included inside the Docker image.*
          draft: false
          prerelease: ${{ contains(github.ref_name, '-alpha') || contains(github.ref_name, '-beta') || contains(github.ref_name, '-rc') }}
