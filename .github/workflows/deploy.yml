name: Deploy to DigitalOcean

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      tag:
        description: 'Docker image tag to deploy (default: latest)'
        required: false
        default: 'latest'
        type: string

  push:
    branches:
      - master
      - feature/cicd  # Временно для тестирования
    paths-ignore:
      - '**.md'
      - 'docs/**'

permissions:
  contents: read
  packages: read

jobs:
  prepare:
    name: Prepare for Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      tag: ${{ steps.set-tag.outputs.tag }}
    steps:
      - name: Set environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            # Auto-deploy only to staging environment on push to master
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Set image tag
        id: set-tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ github.event.inputs.tag }}" != "latest" ]; then
            echo "tag=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
          else
            # For automated pushes to master, use the commit SHA
            echo "tag=sha-${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

  terraform:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: prepare
    # Use GitHub Environment - this enables environment-specific secrets and protection rules
    environment: ${{ needs.prepare.outputs.environment }}
    outputs:
      token: ${{ steps.vault-token.outputs.token }}
      droplet_ip: ${{ steps.terraform-outputs.outputs.droplet_ip }}
      app_url: ${{ steps.terraform-outputs.outputs.app_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Vault
        uses: ./.github/actions/setup-vault
        env:
          VAULT_SERVER_IP: ${{ secrets.VAULT_SERVER_IP }}


      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      - name: Get Vault Token
        id: vault-token
        env:
          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
          VAULT_ROLE_ID: ${{ secrets.VAULT_ROLE_ID }}
          VAULT_SECRET_ID: ${{ secrets.VAULT_SECRET_ID }}
        run: |
          # Create temporary files for role_id and secret_id
          echo "$VAULT_ROLE_ID" > role_id.tmp
          echo "$VAULT_SECRET_ID" > secret_id.tmp
          
          # Get token from Vault
          VAULT_TOKEN=$(vault write -tls-skip-verify -field=token auth/approle/login \
                          role_id=@role_id.tmp \
                          secret_id=@secret_id.tmp)
          
          # Remove temporary files
          rm role_id.tmp secret_id.tmp
          
          # Mask the token in logs for security
          echo "::add-mask::$VAULT_TOKEN"
          
          # Set output and env var
          echo "token=$VAULT_TOKEN" >> $GITHUB_OUTPUT
          echo "VAULT_TOKEN=$VAULT_TOKEN" >> $GITHUB_ENV

      - name: Get Runner IP and Update Firewall
        id: runner-ip
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
        run: |
          # Get runner's public IP
          RUNNER_IP=$(curl -s https://ifconfig.me)
          echo "Runner IP: $RUNNER_IP"
          echo "::add-mask::$RUNNER_IP"
          echo "runner_ip=$RUNNER_IP" >> $GITHUB_OUTPUT
          
          # Set the IP for Terraform
          echo "TF_VAR_runner_ip=$RUNNER_IP" >> $GITHUB_ENV

      - name: Initialize Terraform
        working-directory: .cicd/terraform/compute
        env:
          # Credentials for DigitalOcean Spaces (S3-compatible backend)
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: terraform init

      - name: Terraform Plan
        working-directory: .cicd/terraform/compute
        env:
          # Use environment variables from GitHub Environment if available
          TF_VAR_blue_green_enabled: ${{ vars.BLUE_GREEN_DEPLOYMENT || 'false' }}
          # Optional: Override domain if needed via GitHub Environment variables
          TF_VAR_domain_name: ${{ vars.DEPLOYMENT_DOMAIN || '' }}
          # Credentials for DigitalOcean Spaces (S3-compatible backend)
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          # Use dynamic IP for CI/CD runner instead of 0.0.0.0/0
          terraform plan \
            -var="do_token=${{ secrets.DO_TOKEN }}" \
            -var="ssh_key_fingerprint=${{ secrets.SSH_KEY_FINGERPRINT }}" \
            -var="environment=${{ needs.prepare.outputs.environment }}" \
            -var='allowed_ssh_cidr_blocks=["${{ steps.runner-ip.outputs.runner_ip }}/32", "${{ secrets.VPN_IP }}/32"]' \
            -var="emergency_ssh_access=false" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: .cicd/terraform/compute
        env:
          # Credentials for DigitalOcean Spaces (S3-compatible backend)
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: terraform apply -auto-approve tfplan

      - name: Get Outputs
        id: terraform-outputs
        working-directory: .cicd/terraform/compute
        env:
          # Credentials for DigitalOcean Spaces (S3-compatible backend)
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          echo "droplet_ip=$(terraform output -raw droplet_ipv4)" >> $GITHUB_OUTPUT
          echo "app_url=$(terraform output -raw app_url)" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [prepare, terraform]
    # Use GitHub Environment - this enables environment-specific secrets and protection rules
    environment: ${{ needs.prepare.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Vault CLI
        run: |
          curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
          sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"
          sudo apt-get update && sudo apt-get install vault

      - name: Get SSH Key from Vault
        id: ssh-key
        env:
          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
          VAULT_TOKEN: ${{ needs.terraform.outputs.token }}
        run: |
          # Mask the token in logs for security
          echo "::add-mask::$VAULT_TOKEN"
          
          # Get SSH private key from Vault
          mkdir -p ~/.ssh
          vault kv get -tls-skip-verify -field=private_key kv/ssh > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Set known hosts
          touch ~/.ssh/known_hosts
          echo "${{ needs.terraform.outputs.droplet_ip }} $(vault kv get -tls-skip-verify -field=known_hosts kv/ssh)" >> ~/.ssh/known_hosts

      - name: Copy Docker Compose files
        run: |
          # Prepare docker-compose files
          if [ "${{ needs.prepare.outputs.environment }}" == "production" ]; then
            TARGET_COMPOSE="docker-compose.yml docker-compose.prod.yml"
          else
            TARGET_COMPOSE="docker-compose.yml docker-compose.staging.yml"
          fi
          
          # Copy files to remote server
          scp $TARGET_COMPOSE deploy@${{ needs.terraform.outputs.droplet_ip }}:/var/app/grimwaves/

      - name: Configure Vault Agent
        run: |
          # Create role_id and secret_id files
          echo "${{ secrets.VAULT_ROLE_ID }}" > role_id.tmp
          echo "${{ secrets.VAULT_SECRET_ID }}" > secret_id.tmp
          
          # Copy to server
          scp role_id.tmp deploy@${{ needs.terraform.outputs.droplet_ip }}:/var/app/grimwaves/vault-agent/auth/role-id
          scp secret_id.tmp deploy@${{ needs.terraform.outputs.droplet_ip }}:/var/app/grimwaves/vault-agent/auth/secret-id
          
          # Clean up
          rm role_id.tmp secret_id.tmp

      - name: Run Deployment
        env:
          ENVIRONMENT: ${{ needs.prepare.outputs.environment }}
        run: |
          # Create .env file with the image tag and environment-specific variables
          {
            echo "DOCKER_TAG=${{ needs.prepare.outputs.tag }}"
            echo "ENVIRONMENT=$ENVIRONMENT"
            # Add any environment-specific variables from GitHub Environment
            if [ -n "${{ vars.ADDITIONAL_ENV_VARS }}" ]; then
              echo "${{ vars.ADDITIONAL_ENV_VARS }}"
            fi
          } > .env.tmp
          
          scp .env.tmp deploy@${{ needs.terraform.outputs.droplet_ip }}:/var/app/grimwaves/.env.docker
          
          # Run deployment script
          ssh deploy@${{ needs.terraform.outputs.droplet_ip }} 'cd /var/app/grimwaves && sudo ./deploy.sh'
          
          # Clean up
          rm .env.tmp

      - name: Verify Deployment
        run: |
          # Wait for services to start
          echo "Waiting for services to start..."
          sleep 30
          
          # Check if the service is responding
          curl -sSf --retry 5 --retry-delay 10 "${{ needs.terraform.outputs.app_url }}/health" || (echo "Service health check failed!" && exit 1)
          
          echo "Deployment completed successfully!"

  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [prepare, terraform, deploy]
    if: always()
    # Note: This job does not use an environment context but still accesses environment-specific secrets
    steps:
      - name: Deployment Status
        id: status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=✅ Deployment to ${{ needs.prepare.outputs.environment }} succeeded!" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=❌ Deployment to ${{ needs.prepare.outputs.environment }} failed!" >> $GITHUB_OUTPUT
          fi

      - name: Send Email Notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.MAIL_SERVER }}
          server_port: ${{ secrets.MAIL_PORT }}
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: ${{ steps.status.outputs.message }}
          body: |
            Deployment Status: ${{ steps.status.outputs.status }}
            Environment: ${{ needs.prepare.outputs.environment }}
            Image Tag: ${{ needs.prepare.outputs.tag }}
            Application URL: ${{ needs.terraform.outputs.app_url }}
            
            See details at: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          to: ${{ secrets.MAIL_RECIPIENT }}
          from: GrimWaves CI/CD <${{ secrets.MAIL_USERNAME }}>

  e2e_tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: deploy
    environment: ${{ needs.prepare.outputs.environment }}
    # Only run E2E tests for staging environment
    if: needs.prepare.outputs.environment == 'staging'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: ./.github/actions/setup-python-poetry
        
      - name: Wait for deployment to stabilize
        run: |
          echo "Waiting for 30 seconds to ensure deployment is stable..."
          sleep 30
        
      - name: Run E2E Tests
        env:
          E2E_TEST_URL: https://api-staging.grimwaves.com
        run: |
          poetry run pytest tests/e2e/ -v
          
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results
          path: |
            .pytest_cache/
            pytest-report.xml
          retention-days: 7 