name: Destroy Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment to destroy'
        required: true
        type: choice
        options:
          - staging
          - production
      confirm_destroy:
        description: 'Type "DESTROY" to confirm infrastructure destruction'
        required: true
        type: string
  
  # –í—Ä–µ–º–µ–Ω–Ω–æ –¥–æ–±–∞–≤–ª—è–µ–º push trigger –¥–ª—è feature –≤–µ—Ç–æ–∫ —á—Ç–æ–±—ã workflow –ø–æ—è–≤–∏–ª—Å—è –≤ —Å–ø–∏—Å–∫–µ
  # –≠—Ç–æ—Ç trigger –ù–ï –≤—ã–ø–æ–ª–Ω—è–µ—Ç destroy - —Ç–æ–ª—å–∫–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç workflow –≤ UI
  push:
    branches:
      - 'feature/**'
    paths:
      - '.github/workflows/destroy.yml'  # –¢–æ–ª—å–∫–æ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å–∞–º–æ–≥–æ workflow

permissions:
  contents: read
  packages: read

jobs:
  # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–∞–¥–∞—á–∞ –¥–ª—è push trigger - —Ç–æ–ª—å–∫–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è
  workflow-updated:
    name: Destroy Workflow Updated
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    steps:
      - name: Workflow Updated
        run: |
          echo "üóëÔ∏è Destroy Infrastructure workflow has been updated"
          echo "This workflow is available for manual execution:"
          echo "Actions ‚Üí Destroy Infrastructure ‚Üí Run workflow"
          echo ""
          echo "‚ö†Ô∏è  WARNING: This is a DESTRUCTIVE operation!"
          echo "üí° Always verify the environment before destroying infrastructure"
  
  validate:
    name: Validate Destroy Request
    runs-on: ubuntu-latest
    # –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Ä—É—á–Ω–æ–º –∑–∞–ø—É—Å–∫–µ workflow_dispatch
    if: github.event_name == 'workflow_dispatch'
    outputs:
      environment: ${{ steps.validate.outputs.environment }}
    steps:
      - name: Validate confirmation
        id: validate
        run: |
          if [ "${{ github.event.inputs.confirm_destroy }}" != "DESTROY" ]; then
            echo "‚ùå Confirmation failed. You must type 'DESTROY' exactly to proceed."
            exit 1
          fi
          echo "‚úÖ Confirmation validated"
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT

  terraform-destroy:
    name: Destroy Infrastructure
    runs-on: ubuntu-latest
    needs: validate
    # Use GitHub Environment for secrets and protection rules
    environment: ${{ needs.validate.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Vault
        uses: ./.github/actions/setup-vault
        env:
          VAULT_SERVER_IP: ${{ secrets.VAULT_SERVER_IP }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      - name: Configure AWS CLI for DigitalOcean Spaces
        run: |
          # Install AWS CLI if not present (usually pre-installed in GitHub runners)
          if ! command -v aws &> /dev/null; then
            echo "Installing AWS CLI..."
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            sudo ./aws/install
          else
            echo "AWS CLI already installed: $(aws --version)"
          fi
          
          # Configure AWS CLI for DigitalOcean Spaces
          aws configure set aws_access_key_id "${{ secrets.AWS_ACCESS_KEY_ID }}"
          aws configure set aws_secret_access_key "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          aws configure set default.region fra1
          
          echo "‚úÖ AWS CLI configured for DigitalOcean Spaces"

      - name: Extract SSH Public Key
        id: ssh-public-key
        run: |
          # Create temporary private key file
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > /tmp/deploy_key
          chmod 600 /tmp/deploy_key
          
          # Extract public key from private key
          ssh-keygen -y -f /tmp/deploy_key > /tmp/deploy_key.pub
          
          # Read public key and set as environment variable
          SSH_PUBLIC_KEY=$(cat /tmp/deploy_key.pub)
          echo "::add-mask::$SSH_PUBLIC_KEY"
          echo "TF_VAR_ssh_public_key=$SSH_PUBLIC_KEY" >> $GITHUB_ENV
          
          # Clean up temporary files
          rm -f /tmp/deploy_key /tmp/deploy_key.pub
          
          echo "‚úÖ SSH public key extracted and set for Terraform"

      - name: Get Vault Token
        id: vault-token
        env:
          VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
          VAULT_ROLE_ID: ${{ secrets.VAULT_ROLE_ID }}
          VAULT_SECRET_ID: ${{ secrets.VAULT_SECRET_ID }}
        run: |
          # Create temporary files for role_id and secret_id
          echo "$VAULT_ROLE_ID" > role_id.tmp
          echo "$VAULT_SECRET_ID" > secret_id.tmp
          
          # Get token from Vault
          VAULT_TOKEN=$(vault write -tls-skip-verify -field=token auth/approle/login \
                          role_id=@role_id.tmp \
                          secret_id=@secret_id.tmp)
          
          # Remove temporary files
          rm role_id.tmp secret_id.tmp
          
          # Mask the token in logs for security
          echo "::add-mask::$VAULT_TOKEN"
          
          # Set output and env var
          echo "token=$VAULT_TOKEN" >> $GITHUB_OUTPUT
          echo "VAULT_TOKEN=$VAULT_TOKEN" >> $GITHUB_ENV

      - name: Get Runner IP and Update Firewall
        id: runner-ip
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
        run: |
          # Get runner's public IP
          RUNNER_IP=$(curl -s https://ifconfig.me)
          echo "Runner IP: $RUNNER_IP"
          echo "::add-mask::$RUNNER_IP"
          echo "runner_ip=$RUNNER_IP" >> $GITHUB_OUTPUT
          
          # Set the IP for Terraform
          echo "TF_VAR_runner_ip=$RUNNER_IP" >> $GITHUB_ENV

      - name: Initialize Terraform
        working-directory: .cicd/terraform/compute
        env:
          # Credentials for DigitalOcean Spaces (S3-compatible backend)
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: terraform init

      - name: Check Current State
        working-directory: .cicd/terraform/compute
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          echo "=== Current infrastructure state ==="
          
          # Show current resources in state
          if terraform state list 2>/dev/null | grep -q "."; then
            echo "üìã Resources currently managed by Terraform:"
            terraform state list
            
            echo ""
            echo "üìä Resource summary:"
            terraform state list | wc -l | xargs echo "Total resources:"
          else
            echo "‚ÑπÔ∏è  No resources found in state for ${{ needs.validate.outputs.environment }} environment"
            echo "This may mean:"
            echo "  - Infrastructure was already destroyed"
            echo "  - Wrong environment selected"
            echo "  - State file not found"
            exit 1
          fi

      - name: Terraform Destroy Plan
        working-directory: .cicd/terraform/compute
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          echo "=== Planning infrastructure destruction ==="
          
          terraform plan -destroy \
            -var="do_token=${{ secrets.DO_TOKEN }}" \
            -var="ssh_key_fingerprint=${{ secrets.SSH_KEY_FINGERPRINT }}" \
            -var="ssh_public_key=${{ steps.ssh-public-key.outputs.ssh_public_key }}" \
            -var="environment=${{ needs.validate.outputs.environment }}" \
            -var='allowed_ssh_cidr_blocks=["${{ steps.runner-ip.outputs.runner_ip }}/32"]' \
            -var="vpn_ip=${{ secrets.VPN_IP }}" \
            -var="emergency_ssh_access=false" \
            -out=destroyplan

      - name: Terraform Destroy
        working-directory: .cicd/terraform/compute
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          echo "=== ‚ö†Ô∏è  DESTROYING INFRASTRUCTURE ‚ö†Ô∏è  ==="
          echo "Environment: ${{ needs.validate.outputs.environment }}"
          echo "Initiated by: ${{ github.actor }}"
          echo "Run ID: ${{ github.run_id }}"
          
          # Function to create fresh destroy plan
          create_destroy_plan() {
            echo "üìã Creating fresh destroy plan..."
            terraform plan -destroy \
              -var="do_token=${{ secrets.DO_TOKEN }}" \
              -var="ssh_key_fingerprint=${{ secrets.SSH_KEY_FINGERPRINT }}" \
              -var="ssh_public_key=${{ steps.ssh-public-key.outputs.ssh_public_key }}" \
              -var="environment=${{ needs.validate.outputs.environment }}" \
              -var='allowed_ssh_cidr_blocks=["${{ steps.runner-ip.outputs.runner_ip }}/32", "${{ secrets.VPN_IP }}/32"]' \
              -var="emergency_ssh_access=false" \
              -out=fresh_destroyplan
          }
          
          # First attempt at destroy with existing plan
          if ! terraform apply -auto-approve destroyplan; then
            echo "‚ö†Ô∏è First destroy attempt failed..."
            
            # Check if it's a stale plan error
            if grep -q "Saved plan is stale" <<< "$?"; then
              echo "üîÑ Plan is stale, creating fresh plan..."
              create_destroy_plan
              if ! terraform apply -auto-approve fresh_destroyplan; then
                echo "‚ö†Ô∏è Fresh plan destroy also failed, checking for VPC issues..."
              else
                echo "‚úÖ Fresh plan destroy succeeded!"
                exit 0
              fi
            fi
            
            # Handle VPC cleanup issues
            echo "üîç Checking for VPC cleanup issues..."
            VPC_ID=$(terraform state show digitalocean_vpc.grimwaves_vpc 2>/dev/null | grep -o 'id.*=.*"[^"]*"' | cut -d'"' -f2 || echo "")
            
            if [ -n "$VPC_ID" ]; then
              echo "üîç Found VPC ID: $VPC_ID"
              echo "Attempting manual VPC cleanup..."
              
              # Wait for resources to fully detach
              echo "‚è≥ Waiting 30 seconds for resources to detach..."
              sleep 30
              
              # Try to delete VPC manually via API
              echo "üóëÔ∏è Attempting to delete VPC via API..."
              VPC_DELETE_RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/vpc_response.json -X DELETE \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer ${{ secrets.DO_TOKEN }}" \
                "https://api.digitalocean.com/v2/vpcs/$VPC_ID")
              
              echo "VPC deletion response code: $VPC_DELETE_RESPONSE"
              if [ "$VPC_DELETE_RESPONSE" -eq 204 ]; then
                echo "‚úÖ VPC successfully deleted via API"
                # Remove VPC from terraform state
                terraform state rm digitalocean_vpc.grimwaves_vpc || true
              else
                echo "‚ùå VPC deletion failed, response:"
                cat /tmp/vpc_response.json || echo "No response file"
                
                echo "üîß Removing VPC from state to prevent future issues..."
                terraform state rm digitalocean_vpc.grimwaves_vpc || true
                echo "‚ö†Ô∏è VPC may need manual deletion: https://cloud.digitalocean.com/networking/vpc"
              fi
              
              # Create and apply fresh plan after manual cleanup
              echo "üîÑ Creating final destroy plan..."
              create_destroy_plan
              terraform apply -auto-approve fresh_destroyplan || echo "‚ùå Final destroy attempt failed"
            fi
          else
            echo "‚úÖ Destroy succeeded on first attempt!"
          fi

      - name: Verify Destruction
        working-directory: .cicd/terraform/compute
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          echo "=== Verifying infrastructure destruction ==="
          
          # Check if any resources remain
          REMAINING_RESOURCES=$(terraform state list 2>/dev/null | wc -l)
          
          if [ "$REMAINING_RESOURCES" -eq "0" ]; then
            echo "‚úÖ All infrastructure successfully destroyed!"
            echo "üí∞ No ongoing costs for ${{ needs.validate.outputs.environment }} environment"
          else
            echo "‚ö†Ô∏è  Warning: $REMAINING_RESOURCES resources still exist:"
            terraform state list
            
            # Check specifically for VPC
            if terraform state list | grep -q "digitalocean_vpc.grimwaves_vpc"; then
              echo ""
              echo "üîß VPC still exists in state, attempting final cleanup..."
              
              # Try to remove VPC from state if it can't be destroyed
              VPC_ID=$(terraform state show digitalocean_vpc.grimwaves_vpc 2>/dev/null | grep -o 'id.*=.*"[^"]*"' | cut -d'"' -f2 || echo "")
              
              if [ -n "$VPC_ID" ]; then
                echo "üóëÔ∏è Attempting final VPC deletion via API..."
                if curl -s -X DELETE \
                  -H "Content-Type: application/json" \
                  -H "Authorization: Bearer ${{ secrets.DO_TOKEN }}" \
                  "https://api.digitalocean.com/v2/vpcs/$VPC_ID" | grep -q '"message":"VPC not found"' || true; then
                  echo "‚úÖ VPC successfully deleted or already gone"
                  terraform state rm digitalocean_vpc.grimwaves_vpc || true
                else
                  echo "‚ö†Ô∏è VPC still has dependencies, removing from state"
                  terraform state rm digitalocean_vpc.grimwaves_vpc || true
                  echo "üîß You may need to manually delete VPC: $VPC_ID"
                  echo "   https://cloud.digitalocean.com/networking/vpc"
                fi
              fi
            fi
            
            echo ""
            echo "This may indicate:"
            echo "  - Some resources failed to destroy"
            echo "  - Resources are protected from deletion"
            echo "  - Manual cleanup required"
          fi

  notify:
    if: ${{ false }}
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [validate, terraform-destroy]
    # if: always()
    steps:
      - name: Destruction Status
        id: status
        run: |
          if [[ "${{ needs.terraform-destroy.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=üóëÔ∏è Infrastructure for ${{ needs.validate.outputs.environment }} successfully destroyed!" >> $GITHUB_OUTPUT
            echo "icon=‚úÖ" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=‚ùå Failed to destroy infrastructure for ${{ needs.validate.outputs.environment }}!" >> $GITHUB_OUTPUT
            echo "icon=üí•" >> $GITHUB_OUTPUT
          fi

      - name: Send Email Notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.MAIL_SERVER }}
          server_port: ${{ secrets.MAIL_PORT }}
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "${{ steps.status.outputs.icon }} Infrastructure Destruction - ${{ steps.status.outputs.message }}"
          body: |
            Infrastructure Destruction Report
            
            Status: ${{ steps.status.outputs.status }}
            Environment: ${{ needs.validate.outputs.environment }}
            Initiated by: ${{ github.actor }}
            
            ${{ steps.status.outputs.message }}
            
            Workflow Details:
            - Repository: ${{ github.repository }}
            - Run ID: ${{ github.run_id }}
            - Commit: ${{ github.sha }}
            
            View full logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            
            ---
            ü§ñ Automated notification from GrimWaves CI/CD
          to: ${{ secrets.MAIL_RECIPIENT }}
          from: GrimWaves CI/CD <${{ secrets.MAIL_USERNAME }}> 